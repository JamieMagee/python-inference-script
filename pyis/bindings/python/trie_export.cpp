// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "pyis/ops/text/trie.h"
#include "pyis/share/model_context.h"

namespace pyis {
namespace python {

using pyis::ops::Trie;

namespace py = pybind11;

void init_trie(py::module& m) {
    py::class_<Trie, std::shared_ptr<Trie>>(m, "Trie",
                                            R"pbdoc(
			A Trie implementation which combined Cedar trie and immutable trie
			together. Initially, it is allowed to modify its content. After doing
			"Freeze" operation, the trie is frozen and not allowed to modify, to
			achieve better performace.
		)pbdoc")
        .def(py::init<>())
        .def("insert", &Trie::Insert, py::arg("key"), py::arg("value"), R"pbdoc(
			Insert a key-value pair into the trie. Throws RuntimeError if the trie is frozen.

			Args:
				key (str)
				value (int)
		)pbdoc")
        .def("erase", &Trie::Erase, py::arg("key"), R"pbdoc(
			Erase a specific key from the trie. Throws RuntimeError if the trie is frozen.

			Args:
				key (str): The key to erase.
		)pbdoc")
        .def(
            "lookup",
            [](Trie& self, const std::string& key) {
                auto result = self.Lookup(key);
                if (result.has_error()) {
                    throw result.error();
                }
                return result.value();
            },
            py::arg("key"), R"pbdoc(
			Lookup a specific key-value pair from the trie. Throws RuntimeError if not found.

			Args:
				key (str): The key to lookup.

			Returns:
				value (int): The corrsponding value if pair exists.
		)pbdoc")
        .def("contains", &Trie::Contains, py::arg("key"), R"pbdoc(
			Check if a key in the trie.

			Args:
				key (str): The key to search.

			Returns:
				result (bool): True if the trie contains the key, otherwise False.
		)pbdoc")
        .def("items", &Trie::Items, R"pbdoc(
			Get all key-value pair in the trie.
			
			Returns:
				data (List[Tuple[str, int]]): All key-value pairs in the trie.
		)pbdoc")
        .def("freeze", &Trie::Freeze, R"pbdoc(
			Make the trie frozen.
		)pbdoc")
        .def("load", static_cast<void (Trie::*)(const std::string&)>(&Trie::Load), py::arg("path"), R"pbdoc(
			Load from a binary trie file generated by immutable trie or trie. The trie will
			be frozen after loaded.

			Args: 
				path (str): Path to the binary file.
		)pbdoc")
        .def("save", static_cast<void (Trie::*)(const std::string&)>(&Trie::Save), py::arg("path"), R"pbdoc(
			Save the trie into a binary file. The trie saved will be frozen, thus, it will be a frozen trie
			when it is loaded. However, the orignal trie (the trie which is being saved) will not be frozen.

			Args:
				path (str): Path to the binary file.
		)pbdoc")
        .def(py::pickle(
            [](Trie& self) {
                // __getstate__
                // return a bytes array that fully encodes the state of the object
                std::string state = self.Serialize(ModelContext::GetActive()->Storage());
                return py::bytes(state);
            },
            [](py::bytes& state) {
                // __setstate__
                // create a new C++ instance from the state and files(optional) saved above
                std::shared_ptr<Trie> obj = ModelContext::GetActive()->GetOrCreateObject<Trie>(state);
                return obj;
            }));
}

}  // namespace python
}  // namespace pyis